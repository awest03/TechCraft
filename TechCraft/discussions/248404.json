[
  {
    "Id": "575369",
    "ThreadId": "248404",
    "Html": "\r\n<p>When I try to push the engine to its limits, by drawing 25*25 regions of 16*16*128 blocks, i get an outofmemory caused by the lighting queue.</p>\r\n<p>The problem is in Ligthting.cs, the line :</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>LightRegion(0, WorldSettings.MAPWIDTH, 0, WorldSettings.MAPLENGTH);\r\n</pre>\r\n</div>\r\n<p>&nbsp;When i remove this line , i can render this big world with&nbsp;acceptable FPS on the intel laptop, but the lighting is off. Then i can light regions one by one by adding a block !</p>\r\n<p>I tried to mess with lighting.cs without much success to simulate adding a block in each region, replacing this line with</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>  <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> y = WorldSettings.MAPHEIGHT - WorldSettings.REGIONHEIGHT/2; y &gt; -1; y -= WorldSettings.REGIONHEIGHT)\r\n            {\r\n                <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> x = WorldSettings.REGIONWIDTH / 2; x &lt; WorldSettings.MAPWIDTH; x &#43;= WorldSettings.REGIONWIDTH)\r\n                {\r\n                    <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> z = WorldSettings.REGIONLENGTH / 2; z &lt; WorldSettings.MAPLENGTH; z &#43;= WorldSettings.REGIONLENGTH)\r\n                    {\r\n                        BlockAdded(BlockType.Dirt, x, y, z);\r\n                    }\r\n                }\r\n            }\r\nThe world gets only partially lighted.</pre>\r\n</div>\r\n<p>Any ideas ? At least there may be a way to process&nbsp;only the regions over the ground.&nbsp;</p>\r\n<div id=\"x__mcePaste\" style=\"width:1px; height:1px; overflow:hidden; top:0px; left:-10000px\">\r\n&#65279;</div>\r\n",
    "PostedDate": "2011-03-03T20:32:30.947-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "575659",
    "ThreadId": "248404",
    "Html": "<p>The lighting is fairly buggy to be honest - i never managed to get it to work completely correctly. If you place and remove multiple light blocks in an areas you can&nbsp;get the wrong lighting.</p>\r\n<p>Looking at the code again the LightRegion method which sets up the initial region lighting is definately the culprit. Basically it is queing EVERY block above ground in the region to be processed for lighting....</p>\r\n<pre>                        <span>if</span> (!inShadow)\r\n                        {\r\n                            _lighting[x, y, z] = WorldSettings.MAXLIGHT;\r\n                            toLight.Enqueue(<span>new</span> Light(x, y, z, WorldSettings.MAXLIGHT));\r\n                        }</pre>\r\n<p>The reason for this is to allow the light to fill into areas which are in shadow from the direct overhead 'sun' lighting. The problem is that it's not a very smart algorithm but i'm stumped at the moment as to how it could be improved.</p>\r\n<p>The inShadow check should prevent it lighting areas below ground so that shouldn't be a problem.</p>\r\n<p>The only thing i can think of at the moment is that it could be a 2 stage process so you light for sun</p>\r\n<pre>So in the first pass....</pre>\r\n<pre>                        <span>if</span> (!inShadow)\r\n                        {\r\n                            _lighting[x, y, z] = WorldSettings.MAXLIGHT;</pre>\r\n<pre><span style=\"white-space: pre;\">\t\t\t</span>    //Only do direct SUN lighting.\r\n                            //toLight.Enqueue(<span>new</span> Light(x, y, z, WorldSettings.MAXLIGHT));\r\n                        }</pre>\r\n<pre>Then repeat the process loop but only queue blocks which have unlit neighbours</pre>\r\n<pre>Second pass...</pre>\r\n<pre><pre>                        <span>if</span> (!inShadow)\r\n                        {\r\n</pre>\r\n<pre><span style=\"white-space: pre;\">\t\t\t\t</span>if (hasUnlitNeighbours(x,y,z)) {</pre>\r\n<pre>                            <span style=\"white-space: pre;\">\t\t</span>toLight.Enqueue(<span>new</span> Light(x, y, z, WorldSettings.MAXLIGHT));</pre>\r\n<pre><span style=\"white-space: pre;\">\t\t\t\t</span>}\r\n                        }</pre>\r\n<pre>Obviously since this requires 2 passes it is going to be slower, but since this function is only called once when the region is initialized it shouldn't</pre>\r\n<pre>have too much of an impact.</pre>\r\n<br /></pre>\r\n<pre><br /></pre>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-03-04T09:25:46.763-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "576442",
    "ThreadId": "248404",
    "Html": "<p>Yes it works better, by doing this and changing _lightheight from int to byte I was able to render 37*37 regions of 16*16*128 without filling the memory.</p>\r\n<p>I get 4FPS&nbsp;on the laptop when looking at the whole world, but on the desktop with a geforce 9800GT it still runs fine.</p>\r\n<p>&nbsp;I think won't commit it because it's really marginal cases, we will surely have to redo the lighting when we will display a dynamic set of regions.</p>\r\n<p>Something i saw when pushing the engine like this&nbsp;is that&nbsp;there seems to be no occlusion culling, fps is still very bad when looking at the world from inside a valley,</p>\r\n<p>we re still drawing the whole regions hidden behind the cliff.<span style=\"font-family: Consolas; font-size: xx-small;\"></span></p>",
    "PostedDate": "2011-03-06T19:34:45.37-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]